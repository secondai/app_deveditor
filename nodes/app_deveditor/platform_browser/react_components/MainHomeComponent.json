{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainHomeComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "1424caa3-2102-49dc-abf6-6aef966076f2",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n            \n      const ipfsHashTo32ByteBuffer = function(ipfsHash) {\n        let buf = universe.multihash.fromB58String(ipfsHash)\n        let digest = universe.multihash.decode(buf).digest\n        return digest;\n      }\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            showBuy: false,\n            validating: false,\n            stellarSeed: '', //process.env.REACT_APP_CLOUD_STELLAR_SEED,\n            username: '',\n            passphrase: '',\n            confirmPassphrase: '',\n            startupZipUrl: 'https://github.com/secondai/cloud_appstore', // bundle_cloud_smart_assistant_default\n            generatingLumens: false,\n            lumensMessage: null,\n            errorMessages: [],\n            validated: false,\n            usernameClaimed: null,\n            usernameAvailable: null,\n            claiming: null,\n            horizonPossible: [\n              {\n                name: 'PubNet (real money)',\n                address: 'https://horizon.stellar.org',\n                network: 'public'\n              },\n              {\n                name: 'TestNet (for development)',\n                address: 'https://horizon-testnet.stellar.org',\n                network: 'test'\n              }\n            ],\n            horizonServerAddress: 1 // public or test\n          }\n        }\n        componentDidMount(){\n          // console.log(this.props);\n          // this.props.auth.update();\n        }\n      \n        @autobind\n        updateUsername(e){\n          let username = e.target.value.normalize('NFKC').toLowerCase();\n          console.log('username:', username);\n          this.setState({\n            username,\n            usernameAvailable: false\n          })\n        }\n      \n        @autobind\n        generateStellarSeed(){\n          // creates the Stellar seed for your controlling account (NOT identity, for creating identity from this) \n          // - makes the testnet \"give me 1000 Lumens\" request \n      \n          var stellarServer;\n          let horizon = this.state.horizonPossible[this.state.horizonServerAddress];\n          switch(horizon.network){\n            case 'public':\n              universe.StellarSdk.Network.usePublicNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            case 'test':\n              universe.StellarSdk.Network.useTestNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            default:\n              return false;\n          }\n      \n          this.setState({\n            generatingLumens: true,\n            lumensMessage: null\n          });\n      \n          // // let pkSeed = crypto.createHash('sha256').update('blah blah this is my custom account').digest(); //returns a buffer\n          // let pkSeed = SHA256('testing this out');\n          // console.log('pkSeed:', pkSeed);\n          // var pair = StellarSdk.Keypair.fromRawEd25519Seed(pkSeed);\n          var pair = universe.StellarSdk.Keypair.random(); //fromRawEd25519Seed(pkSeed);\n      \n          this.setState({\n            stellarSeed: pair.secret()\n          });\n      \n          // let stellarKeys = {\n          //   private: pair.secret(),\n          //   public: pair.publicKey()\n          // }\n          // console.log('stellarKeys',stellarKeys);\n      \n          // Send request to testnet-bot to create sample lumens \n          if(horizon.network != 'test'){\n            this.setState({\n              generatingLumens: false\n            });\n      \n            prompt('Copy this Seed/Secret value and back it up (it will only be shown once!)',pair.secret());\n            return;\n          }\n      \n          var url = new WINDOW.URL('https://friendbot.stellar.org/'),\n            params = { addr: pair.publicKey() };\n          Object.keys(params).forEach(key => url.searchParams.append(key, params[key]))\n      \n      \n          universe.fetch(url)\n          .then(response=>{\n            console.log('Response1:', response);\n            if(response.status == 200){\n              return response;\n            }\n            // failed!\n            this.setState({\n              generatingLumens: false,\n              lumensMessage: 'Failed populating seed wallet'\n            })\n            throw \"Failed populating seed wallet with Friendbot lumens\"\n          })\n          .then(response=>response.json())\n          .then(response=>{\n            console.log('Friendbot Response:', response);\n      \n            prompt('Funded on TestNet. Copy this Seed/Secret value (it will only be shown once!)',pair.secret());\n      \n            this.setState({\n              generatingLumens: false\n            });\n      \n            this.getBalance();\n      \n          })\n          .catch(err=>{\n            console.error('Failed Response', err);\n          })\n      \n      \n      \n          // }, function(error, response, body) {\n          //   if (error || response.statusCode !== 200) {\n          //     console.error('ERROR!', error || body);\n          //   }\n          //   else {\n          //     console.log('SUCCESS! You have a new account :)\\n', body);\n          //   }\n      \n      \n          //   this.setState({\n          //     generatingLumens: false\n          //   });\n      \n          // });\n      \n      \n          // // the JS SDK uses promises for most actions, such as retrieving an account\n          // stellarServer.loadAccount(stellarKeys.public)\n          // .catch(StellarSdk.NotFoundError, function (error) {\n          //   throw new Error('The destination account does not exist!');\n          // })\n          // .then(function(account) {\n          //   console.log('Balances for account: ' + stellarKeys.public);\n          //   account.balances.forEach(function(balance) {\n          //     console.log('Type:', balance.asset_type, ', Balance:', balance.balance);\n          //   });\n          // });\n      \n      \n          // // // Run a transaction FROM the target (needs to be sent money, then send money out?) \n          // let pkTargetSeed = crypto.createHash('sha256').update('testing103').digest(); //returns a buffer\n          // var pairTarget = StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n      \n          // let stellarKeysTarget = {\n          //   private: pairTarget.secret(),\n          //   public: pairTarget.publicKey()\n          // }\n      \n          // console.log('stellarKeysTarget',stellarKeysTarget);\n      \n          // // get transactions for Target\n      \n          // var destinationId = stellarKeysTarget.public;\n      \n          // // Transaction will hold a built transaction we can resubmit if the result is unknown.\n          // var transaction;\n      \n      \n          // // // the JS SDK uses promises for most actions, such as retrieving an account\n          // // stellarServer.loadAccount(destinationId)\n          // // .catch(StellarSdk.NotFoundError, function (error) {\n          // //   console.error('The destination account does not exist! (expected when creating new identity!)');\n          // // })\n          // // .then(function(account) {\n          // //   console.log('Balances for account: ' + stellarKeys.public);\n          // //   account.balances.forEach(function(balance) {\n          // //     console.log('Type:', balance.asset_type, ', Balance:', balance.balance);\n          // //   });\n          // // });\n      \n      \n          // // First, check to make sure that the destination account exists.\n      \n          // const ipfsHashTo32ByteBuffer = function(ipfsHash) {\n          //   let buf = multihash.fromB58String(ipfsHash)\n          //   let digest = multihash.decode(buf).digest\n          //   return digest;\n          // }\n      \n          // let b32 = ipfsHashTo32ByteBuffer('Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR');\n      \n          // let tmp1 = new Buffer('+FYuRGmZIz/e/T0UungCrIbiMCwukMFzPJWAHzsLH84=','base64'); //.toString('hex');\n          // console.log('Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR');\n          // let digest1 = multihash.encode(tmp1, 'sha2-256');\n          // let hash1 = multihash.toB58String(digest1);\n          // console.log(hash1);\n      \n          // // let b32 = crypto.createHash('sha256').update('test').digest(); //returns a buffer\n          // // console.log('b32:', b32.toString('hex'));\n          // // let str2 = new Buffer('n4bQgYhMfWWaL+qgxVrQFaO/TxsrC4Is0V1sFbDwCgg=','base64').toString('hex')\n          // // console.log('same?:', str2); //bs58.decode(str2).toString('hex'));\n      \n          // // stellarServer.loadAccount(stellarKeys.public)\n          // //   // // If the account is not found, surface a nicer error message for logging.\n          // //   // .catch(StellarSdk.NotFoundError, function (error) {\n          // //   //   throw new Error('The destination account does not exist!');\n          // //   // })\n          // //   // If there was no error, load up-to-date information on your account.\n          // //   // .then(function() {\n          // //   //   return stellarServer.loadAccount(stellarKeys.public);\n          // //   // })\n          // //   .then(function(sourceAccount) {\n          // //     // Start building the transaction.\n          // //     transaction = new StellarSdk.TransactionBuilder(sourceAccount)\n                \n          // //       .addOperation(StellarSdk.Operation.createAccount({\n          // //         destination: pairTarget.publicKey(),\n          // //         startingBalance: \"10\"\n          // //         // source: pair\n          // //       }))\n      \n          // //       // A memo allows you to add your own metadata to a transaction. It's\n          // //       // optional and does not affect how Stellar treats the transaction.\n          // //       // .addMemo(StellarSdk.Memo.text('Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR'))\n          // //       .addMemo(StellarSdk.Memo.hash(b32))\n          // //       .build();\n          // //     // Sign the transaction to prove you are actually the person sending it.\n          // //     transaction.sign(pair); // sourceKeys\n          // //     // send to stellar network\n          // //     return stellarServer.submitTransaction(transaction);\n          // //   })\n          // //   .then(function(result) {\n          // //     console.log('Stellar Success! Results:', result);\n          // //   })\n          // //   .catch(function(error) {\n          // //     console.error('Stellar Something went wrong!', error);\n          // //     // If the result is unknown (no response body, timeout etc.) we simply resubmit\n          // //     // already built transaction:\n          // //     // server.submitTransaction(transaction);\n          // //   });\n      \n      \n      \n      \n          // // // Get the 1st (on page 1 only!) transaction where the memo is an ipfs hash \n          // // stellarServer.transactions()\n          // //   .forAccount(destinationId)\n          // //   .call()\n          // //   .then(function (page) {\n          // //     console.log('Page 1: ', page.records.length);\n          // //     console.log(JSON.stringify(page.records,null,2));\n          // //     // console.log(page.records.length);\n          // //   })\n      \n      \n        }\n      \n        @autobind\n        async buyLumens(){\n      \n          alert('Not yet available');\n      \n        }\n      \n        @autobind\n        async getBalance(){\n      \n          var stellarServer;\n          let horizon = this.state.horizonPossible[this.state.horizonServerAddress];\n          switch(horizon.network){\n            case 'public':\n              universe.StellarSdk.Network.usePublicNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            case 'test':\n              universe.StellarSdk.Network.useTestNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            default:\n              return false;\n          }\n      \n          let {\n            stellarSeed,\n            username,\n            passphrase\n          } = this.state;\n      \n          let currentBalance;\n      \n          this.setState({\n            gettingBalance: true,\n            currentBalance: null\n          });\n      \n          var pairSource;\n      \n          // Load source account\n          let sourceAccount;\n          try {\n            pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarSeed);\n            sourceAccount = await stellarServer.loadAccount(pairSource.publicKey())\n          }catch(err){\n            // problem with account \n            alert('Account does not exist');\n            sourceAccount = null;\n          }\n      \n          // get source balance \n          if(sourceAccount){\n            currentBalance = sourceAccount.balances[0].balance;\n          }\n      \n          this.setState({\n            gettingBalance: false,\n            currentBalance\n          });\n      \n        }\n      \n        @autobind\n        async validate(){\n      \n          // validate a username/identity \n      \n          var stellarServer;\n          let horizon = this.state.horizonPossible[this.state.horizonServerAddress];\n          switch(horizon.network){\n            case 'public':\n              universe.StellarSdk.Network.usePublicNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            case 'test':\n              universe.StellarSdk.Network.useTestNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            default:\n              return false;\n          }\n      \n      \n          let validated = false;\n      \n          let {\n            stellarSeed,\n            username,\n            passphrase\n          } = this.state;\n      \n          if(!username){\n            return false;\n          }\n      \n      \n          let subname = ''; // empty is for root \n          let usernameSplit = username.split('@');\n          if(usernameSplit.length > 1){\n            subname = usernameSplit[0];\n            username = usernameSplit[1];\n          }\n      \n          this.setState({\n            errorMessages: [],\n            validated: false,\n            validating: true,\n            usernameClaimed: null,\n            usernameAvailable: null,\n            identityAccountId: null\n          });\n      \n          let usernameClaimed = null;\n          let usernameAvailable = null;\n      \n          // validate stellar seed \n          // - an account with enough Lumens in it \n      \n          var pairSource;\n      \n          let errors = [];\n      \n          // Load source account\n          let sourceAccount;\n          try {\n            pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarSeed);\n            sourceAccount = await stellarServer.loadAccount(pairSource.publicKey())\n          }catch(err){\n            // problem with account \n            errors.push('The seed stellar account does not exist!');\n            sourceAccount = null;\n          }\n      \n          // get source balance \n          if(sourceAccount){\n            let balance = 0;\n            balance = sourceAccount.balances[0].balance;\n      \n            console.log('Balance:', balance);\n      \n            balance = parseInt(balance,10);\n            if(balance < 10){\n              errors.push('Insufficient balance in source account (need 10+ lumens)');\n            }\n          }\n      \n          // validate that Identity is available (or already owned)\n          // - should be a nonexistant account (or have my sourcePublicKey as a signer) \n          // - TODO: \"rent\" via smart contracts \n      \n          let pkTargetSeed = universe.jsSHA256.array(username);\n          var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n      \n          this.setState({\n            identityAccountId: pairTarget.publicKey()\n          });\n      \n          let targetAccount;\n          try {\n            targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n            console.log('targetAccount:', targetAccount);\n      \n            // if reach here, then username is taken! \n            // - check to see if our sourceKeys are a signer (aka I'm the owner) \n      \n            usernameClaimed = {};\n      \n            // get the current value of the Second ipfshash \n            let secondHash = await targetAccount.data({key: subname + '|second'})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              return null;\n            })\n      \n            console.log('secondHash:', secondHash);\n      \n            usernameClaimed.hash = secondHash;\n      \n            let sourceIsSigner = _.find(targetAccount.signers,{public_key: pairSource ? pairSource.publicKey():'skip'});\n            if(sourceIsSigner){\n              // already claimed, but I'm the owner \n              usernameClaimed.owned = true;\n      \n            } else {\n              // exists, and I'm not the owner \n              // - could also check to see if it is unprotected? (unlikely, maybe on testnet only) \n              // - could check the \"data.willSellFor\" field to see if it is for sale? \n              errors.push('Identity/username already claimed');\n              targetAccount = null;\n      \n              usernameClaimed.owned = false;\n      \n            }\n      \n            this.setState({\n              usernameClaimed\n            });\n      \n      \n      \n      \n            // // var pairSource = StellarSdk.Keypair.fromSecret(this.state.stellarSeed);\n            // // let pkTargetSeed = SHA256.array(username);\n            // // var pairTarget = StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n      \n            // // Update data \n      \n            // // Start building the transaction.\n            // let transaction = new StellarSdk.TransactionBuilder(targetAccount)\n      \n            // .addOperation(StellarSdk.Operation.manageData({\n            //   name: 'ipfshash',\n            //   value: 'Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR'\n            // }))\n      \n            // // A memo allows you to add your own metadata to a transaction. It's\n            // // optional and does not affect how Stellar treats the transaction.\n            // // .addMemo(StellarSdk.Memo.text('Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR'))\n            // // .addMemo(StellarSdk.Memo.hash(b32))\n            // .build();\n      \n            // // Sign the transaction to prove you are actually the person sending it.\n            // transaction.sign(pairTarget); // sourceKeys\n            // transaction.sign(pairSource); // sourceKeys\n      \n            // // send to stellar network\n            // stellarServer.submitTransaction(transaction)\n            // .then(function(result) {\n            //   console.log('Stellar manageData Success! Results:', result);\n            // })\n            // .catch(function(error) {\n            //   console.error('Stellar Something went wrong (failed updating data)!', error);\n            //   // If the result is unknown (no response body, timeout etc.) we simply resubmit\n            //   // already built transaction:\n            //   // server.submitTransaction(transaction);\n            // });\n      \n      \n      \n            // return false;\n      \n      \n      \n          }catch(err){\n            // account doesnt exist, good!\n            console.log('targetAccount doesnt exist, good!');\n            usernameAvailable = true;\n          }\n      \n          if(!errors.length){\n            validated = true;\n          }\n      \n          console.log('errorMessages:', errors);\n          console.log('validated:', validated);\n      \n          this.setState({\n            validating: false,\n            validated,\n            errorMessages: errors,\n            usernameAvailable\n          });\n      \n        }\n      \n        @autobind\n        async claimUsername(username){\n          // sets up the identity\n          // - assuming NOT setup at all yet \n          // - error if already created \n      \n          // also sets up multi-sig control over data! \n      \n      \n          // validate stellar seed \n          // - an account with enough Lumens in it \n      \n          var stellarServer;\n          let horizon = this.state.horizonPossible[this.state.horizonServerAddress];\n          switch(horizon.network){\n            case 'public':\n              universe.StellarSdk.Network.usePublicNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            case 'test':\n              universe.StellarSdk.Network.useTestNetwork();\n              stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              WINDOW.stellar = universe.StellarSdk;\n              break;\n            default:\n              return false;\n          }\n      \n          this.setState({\n            claiming: true\n          });\n      \n      \n          let subname = ''; // empty is for root \n          let usernameSplit = username.split('@');\n          if(usernameSplit.length > 1){\n            subname = usernameSplit[0];\n            username = usernameSplit[1];\n          }\n      \n          var pairSource = universe.StellarSdk.Keypair.fromSecret(this.state.stellarSeed);\n      \n          let errors = [];\n      \n          // Load source account\n          let sourceAccount;\n          try {\n            sourceAccount = await stellarServer.loadAccount(pairSource.publicKey())\n          }catch(err){\n            // problem with account \n            alert('The seed stellar account does not exist!');\n      \n            this.setState({\n              claiming: false\n            });\n            return false;\n          }\n      \n          // get source balance \n          if(sourceAccount){\n            let balance = 0;\n            balance = sourceAccount.balances[0].balance;\n      \n            console.log('Balance:', balance);\n      \n            balance = parseInt(balance,10);\n            if(balance < 10){\n              alert('Insufficient balance in source account (need 10+ lumens)');\n      \n              this.setState({\n                claiming: false\n              });\n      \n              return false;\n            }\n          }\n      \n          // validate that Identity is available (or already owned)\n          // - should be a nonexistant account (or have my sourcePublicKey as a signer) \n          // - TODO: \"rent\" via smart contracts \n      \n          let pkTargetSeed = universe.jsSHA256.array(username);\n          var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n      \n          let targetAccount;\n          try {\n            targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n            console.log('targetAccount:', targetAccount);\n            alert('Identity already exists, cant claim');\n      \n            this.setState({\n              claiming: false\n            });\n      \n            return false;\n          }catch(err){\n      \n          }\n      \n          // Start building the transaction.\n          // - fees: https://www.stellar.org/developers/guides/concepts/fees.html\n          // - starting balance: (2 + # of entries) × base reserve\n          //   - 2 signers (original, my secret) \n          //   - 1 Data entry \n          let transaction = new universe.StellarSdk.TransactionBuilder(sourceAccount)\n          .addOperation(universe.StellarSdk.Operation.createAccount({\n            destination: pairTarget.publicKey(),\n            startingBalance: \"5.0\" // 2.5 is required, 2.5 extra for manageData entries (allows for 4 entries? second, nodechain, ...) \n            // source: pair\n          }))\n      \n          // A memo allows you to add your own metadata to a transaction. It's\n          // optional and does not affect how Stellar treats the transaction.\n          // .addMemo(StellarSdk.Memo.text('Qmf4437bCR2cwwpPh6dChwMSe5wuLJz32caf2aZP3xxtNR'))\n          // .addMemo(StellarSdk.Memo.hash(b32))\n          .build();\n      \n          // Sign the transaction to prove you are actually the person sending it.\n          transaction.sign(pairSource); // sourceKeys\n      \n          // send to stellar network\n          let stellarResult = await stellarServer.submitTransaction(transaction)\n          .then(function(result) {\n            console.log('Stellar Success! Results:', result);\n            return result;\n          })\n          .catch(function(error) {\n            console.error('Stellar Something went wrong!', error);\n            // If the result is unknown (no response body, timeout etc.) we simply resubmit\n            // already built transaction:\n            // server.submitTransaction(transaction);\n            return null;\n          });\n      \n          console.log('stellarResult', stellarResult);\n          if(!stellarResult){\n            alert('Failed claiming account');\n      \n            this.setState({\n              claiming: false\n            });\n      \n            return false;\n          }\n      \n      \n          targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n      \n          // Add multisig \n          console.log('adding multisig', targetAccount);\n      \n          // set multi-sig on this account \n          // - will fail if I am unable to \"claim\" \n      \n          // Start building the transaction.\n          let transaction2 = new universe.StellarSdk.TransactionBuilder(targetAccount)\n      \n          .addOperation(universe.StellarSdk.Operation.manageData({\n            name: '|second',\n            value: '-'\n          }))\n      \n          .addOperation(universe.StellarSdk.Operation.setOptions({\n            signer: {\n              ed25519PublicKey: pairSource.publicKey(),\n              weight: 1\n            }\n          }))\n          .addOperation(universe.StellarSdk.Operation.setOptions({\n            masterWeight: 1, // set master key weight (should really be nothing, and controlled by this other key?) \n            lowThreshold: 2, // trustlines\n            medThreshold: 2, // manageData\n            highThreshold: 2  // setOptions (multi-sig)\n          }))\n          .build();\n      \n          // Sign the transaction to prove you are actually the person sending it.\n          transaction2.sign(pairTarget); // sourceKeys\n          // transaction2.sign(pairSource); // sourceKeys\n      \n          // send to stellar network\n          let stellarResult2 = await stellarServer.submitTransaction(transaction2)\n          .then(function(result) {\n            console.log('Stellar MultiSig Setup Success! Results:', result);\n            return result\n          })\n          .catch(function(error) {\n            console.error('Stellar Something went wrong (failed multisig)!', error);\n            // If the result is unknown (no response body, timeout etc.) we simply resubmit\n            // already built transaction:\n            // server.submitTransaction(transaction);\n            return null;\n          });\n      \n          console.log('Multisig result:', stellarResult2);\n      \n          if(!stellarResult2){\n            alert('Failed multisig setup');\n      \n            this.setState({\n              claiming: false\n            });\n      \n            return false;\n          }\n      \n          alert('Claimed Username');\n      \n          // re-run validation (to verify changes worked!) \n          await this.validate();\n      \n          this.setState({\n            claiming: false\n          });\n      \n          return true;\n      \n        }\n      \n        @autobind\n        async launch(){\n      \n          // // check passwords\n          // if(this.state.passphrase != this.state.confirmPassphrase){\n          //   alert('Passwords do not match');\n          //   return false;\n          // }\n      \n          // Claim the username if necessary \n          if(this.state.usernameClaimed){\n            // username was claimed \n            if(this.state.usernameClaimed.owned){\n      \n              console.log('Already claimed (will be updating when Second launches)');\n      \n            } else {\n              alert('Cannot launch with identity you cant control');\n              return false;\n            }\n      \n          } else {\n      \n            // Setup the account (assuming it hasn't been setup before) \n      \n            let claimed = await this.claimUsername(this.state.username);\n      \n            console.log('Claimed result:', claimed);\n      \n      \n          }\n      \n      \n          let launchUrl = 'https://heroku.com/deploy';\n      \n          let horizon = this.state.horizonPossible[this.state.horizonServerAddress];\n      \n          var url = new WINDOW.URL(launchUrl),\n            params = { \n              template: 'https://github.com/secondai/env_cloud_default/tree/master',\n              'env[STELLAR_SEED]': this.state.stellarSeed,\n              'env[STELLAR_NETWORK]': horizon.network,\n              'env[BASICS_ZIP_URL]': this.state.startupZipUrl,\n              'env[STARTUP_REACHABLE_WORDS]': this.state.username,\n              'env[DEFAULT_PASSPHRASE]': this.state.passphrase,\n            };\n      \n          Object.keys(params).forEach(key => url.searchParams.append(key, params[key]))\n      \n      \n          console.log('launching in new window!', url.toString());\n          // return false;\n      \n          WINDOW.open(url.toString());\n      \n          this.setState({\n            launchUrl: url.toString()\n          });\n      \n        }\n      \n        render() {\n      \n          return [\n            <section key={1} className=\"section\">\n              <div className=\"container\">\n                <div className=\"columns\">\n      \n                  <div className=\"column is-offset-3 is-6 has-text-center\">\n      \n                    <div className={\"modal \" + (this.state.showBuy ? 'is-active':'')}>\n                      <div className=\"modal-background\" onClick={e=>this.setState({showBuy:false})}></div>\n                      <div className=\"modal-content\">\n                        <div className=\"box content\">\n      \n                          <h3 className=\"title is-4\">\n                            Purchase how many usernames?\n                          </h3>\n      \n                          <p>\n                            <a href=\"/cloud\" className=\"button\">1 Username - $1</a>\n                          </p>\n                          <p>\n                            <a href=\"/cloud\" className=\"button\">3 Usernames - $2.75</a>\n                          </p>\n                          <p>\n                            <a href=\"/cloud\" className=\"button\">10 Usernames - $8.50</a>\n                          </p>\n      \n                        </div>\n                      </div>\n                      <button className=\"modal-close is-large\" aria-label=\"close\" onClick={e=>this.setState({showBuy:false})}></button>\n                    </div>\n      \n                    <h3 className=\"title is-3\">\n                      Launch New Second \n                    </h3>\n                    <h3 className=\"subtitle is-6\">\n                      With default App Store (Stellar test network) (<Link to=\"/cloud-advanced\">advanced</Link>)\n                    </h3>\n      \n      \n                    <hr />\n      \n      \n      \n      \n                    <div className=\"field\">\n                      <label className=\"label\">Seed</label>\n                    </div>\n      \n                    <div className=\"field has-addons\" style={{marginBottom:'0px'}}>\n                      <div className=\"control is-expanded has-icons-right\">\n                        <input className=\"input\" type=\"text\" placeholder=\"\" value={this.state.stellarSeed} onChange={e=>this.setState({stellarSeed: e.target.value})} />\n                        {\n                          this.state.generatingLumens ?\n                          <span className=\"icon is-small is-right has-text-info\">\n                            <i className=\"fa fa-spinner fa-pulse\"></i>\n                          </span>:''\n                        }\n                      </div>\n                      \n                      <div className=\"control\">\n                        <button className={\"button is-default \" + (this.state.gettingBalance ? 'is-loading':'')} onClick={this.getBalance}>Get Balance {\n                          this.state.currentBalance\n                        }</button>\n                      </div>\n      \n                      {/*\n                      <div className=\"control\">\n                        <button className={\"button is-default\"} onClick={e=>this.setState({showBuy:true})}>No Lumens? Buy Some!</button>\n                      </div>\n                      */}\n                      \n                    </div>\n      \n                    <div className=\"field\">\n                      {/*\n                      <label className=\"label\">Stellar Seed</label>\n                      <div className=\"control has-icons-right\">\n                        <input className=\"input\" type=\"text\" placeholder=\"\" value={this.state.stellarSeed} onChange={e=>this.setState({stellarSeed: e.target.value})} />\n                        {\n                          this.state.generatingLumens ?\n                          <span className=\"icon is-small is-right has-text-info\">\n                            <i className=\"fa fa-spinner fa-pulse\"></i>\n                          </span>:''\n                        }\n                      </div>*/}\n                      {\n                        !this.state.lumensMessage ? '':\n                        <p className=\"help has-text-danger\">\n                          {this.state.lumensMessage}\n                        </p>\n                      }\n                      <p className=\"help\">\n                        Lumens Required: \"5.0\" [<a onClick={this.generateStellarSeed}>generate seed</a>]\n                      </p>\n                    </div>\n      \n      \n                      <br />\n      \n      \n                    <div className=\"field\">\n                      <label className=\"label\">Username</label>\n                    </div>\n      \n                    <div className=\"field has-addons\" style={{marginBottom:'0px'}}>\n                      <div className=\"control is-expanded\">\n                        <input autoFocus className=\"input\" type=\"text\" placeholder=\"lowercase values only\" value={this.state.username} \n                          onChange={this.updateUsername} \n                          onKeyPress={(event) => {\n                            if (event.key === \"Enter\") {\n                              this.validate()\n                            }\n                          }}\n                          />\n                      </div>\n                      \n                      {\n                        !this.state.usernameAvailable ? '':\n                        <div className=\"control\">\n                          <button className={\"button is-success \" + (this.state.claiming ? 'is-loading':'') } onClick={e=>this.claimUsername(this.state.username)}>Claim Immediately</button>\n                        </div>\n                      }\n      \n                      <div className=\"control\">\n                        <button className={\"button is-info \" + (this.state.validating ? 'is-loading':'') } onClick={this.validate}>Check Username</button>\n                      </div>\n      \n                    </div>\n      \n                    <div className=\"field\">\n      \n                      {\n                        !this.state.usernameAvailable ? '':\n                        <p className={\"help has-text-success\"}>\n                          Username Available!\n                        </p>\n                      }\n      \n                      {/*\n                        !this.state.identityAccountId ? '':\n                        <p className=\"help\">\n                          Account: <a href={`${this.state.horizonPossible[this.state.horizonServerAddress].address}/accounts/${this.state.identityAccountId}`} target=\"_blank\">{this.state.identityAccountId}</a>\n                        </p>\n                      */}\n                      {\n                        !this.state.usernameClaimed ? '':\n                        <p className={\"help \" + (this.state.usernameClaimed.owned ? 'has-text-success':'has-text-danger')}>\n                          {\n                            this.state.usernameClaimed.owned ?\n                            'You are the owner already! Continuing will eventually overwrite the previous configuration for this username'\n                            :\n                            <div>\n                              You are NOT the owner of this username\n                            </div>\n                          }\n                        </p>\n                      }\n      \n                    </div>\n      \n                    <br />\n      \n      \n                    <div className=\"field\">\n                      <label className=\"label\">Admin Passphrase</label>\n                      <div className=\"control\">\n                        <input className=\"input\" type=\"password\" placeholder=\"\" value={this.state.passphrase} onChange={e=>this.setState({passphrase: e.target.value})} />\n                      </div>\n                      {/*\n                      <p className=\"help\">\n                        This is the passphrase you'll use for full and complete access (you'll add additional users/permissions later) \n                      </p>\n                      */}\n                    </div>\n      \n      \n                    {/*\n                    <div className=\"field\">\n                      <label className=\"label\">Startup Bundle Zip URL</label>\n                      <div className=\"control\">\n                        <input className=\"input\" type=\"text\" placeholder=\"\" value={this.state.startupZipUrl} onChange={e=>this.setState({startupZipUrl: e.target.value})} />\n                      </div>\n                      <p className=\"help\">\n                        The default bundle of Nodes to use when launching a Cloud Second\n                      </p>\n                    </div>\n                    */}\n      \n      \n                    <br />\n      \n                    <div className=\"field is-grouped\">\n                      {/*\n                      <div className=\"control\">\n                        <button className={\"button is-default \" + (this.state.validating ? 'is-loading':'') } onClick={this.validate}>Check Username</button>\n                      </div>\n                      */}\n      \n                      {\n                        (!this.state.validated || (this.state.usernameClaimed && this.state.usernameClaimed.owned == false)) ? \n                          <div className=\"control\">\n                            <button className={\"button is-default\"} disabled={true}>Validate Username Before Continuing</button>\n                          </div>\n                        :\n                          <div className=\"control\">\n                            <button className={\"button is-info\"} onClick={this.launch}>{!this.state.usernameClaimed ? 'Claim Username and ':''}Continue to Heroku</button>\n                          </div>\n                      }\n      \n                    </div>\n                    {\n                      !this.state.launchUrl ? '':\n                      <p>\n                        <a href={this.state.launchUrl}>{this.state.launchUrl}</a>\n                      </p>\n                    }\n      \n                    {\n                      !this.state.errorMessages.length ? '':\n                      <div className=\"message is-danger\">\n                        <div className=\"message-body\">\n                          {\n                            this.state.errorMessages.map((msg,i)=>(\n                              <div key={i + msg}>\n                                {msg}\n                              </div>\n                            ))\n                          }\n                        </div>\n                      </div> \n                    }\n      \n                    <br />\n      \n                    <p>\n                      After creating, visit the <a href=\"https://browserapp.getasecond.com\">browser app</a>* to connect to your Cloud Second using your created username and password\n                      <br />\n                      <small>\n                        * eventually your Second will host the environment \n                      </small>\n                    </p>\n      \n                  </div>\n                </div>\n              </div>\n      \n            </section>\n      \n          ]\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainHomeComponent"
  }
}